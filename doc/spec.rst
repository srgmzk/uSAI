**Intro**

Эта спецификация определяет интерфейс абстракции коммутатора (SAI) для элементов форвардинга, таких
как коммутирующий ASIC, NPU или софтварный коммутатор. SAI API разработан, так тобы предоставить 
независимый от вендора унифицированный способ управления элементами форвардинга. Эта спецификация 
также позволяет раскрыть функциональные возможности конкретных вендоров и расширения существующих 
функций. 

**Определения**

*Adapter* - это подключаемый модуль кода, который реализует SAI для данного элемента форвардинга.

*Control Stack (CS)* - это набор программных компонентов, которые представляет хост и вызывающие 
модули со стороны SAI, а также обеспечивает поддержку программирования более высокого уровня для 
приложений  управления сетью. Его также иногда называют "application" или "user".

*Adapter host (AH)* - это программный компонент, который загружает адаптер и предоставляет его 
функции Стеку управления с другой стороны.

*Forwarding Element (FE)* - это реализация плоскости передачи сетевого трафика, для которой 
адаптируется данный экземпляр SAI Adapter. Например, это может быть микросхема коммутатора, NPU 
или программный коммутатор. 

**High-Level design notes**

Адаптер - это драйвер, который реализует сервисный уровень SAI для данного FE, и обычно (хотя и не 
обязательно) поставляется с этим FE. Адаптер отвечает за обнаружение и привязку к FE, включая 
загрузку или привязку к любым другим сабмодулям, которые ему необходимы.

Адаптер должен быть максимально простым, не содержать постоянной конфигурации и сохранять только 
состояние, полученное из CS и FE, необходимое для выполнения его задачи. Дизайн стремится перенести
сложность расчётов из Адаптера в CS, везде где это возможно. 

Модуль Адаптера загружается в процесс хоста («Adapter Host»), а затем инициализируется. Во время 
инициализации Aдаптер инициирует процесс обнаружения указанного экземпляра FE.

Одновременно может работать несколько AH. Каждый AH может отвечать за управлением частью функций в 
FE. Например, AH IP-маршрутизации может отвечать за синхронизацию IP-маршрутов с FE, а другой AH 
может отвечать за опрос счетчиков из FE. 

Ключевые предположения, проектные решения и пояснения семантики API:

* API для управления объектами SAI основано на CRUD (создание/чтение/обновление/удаление)

* Адаптер не является источником критического постоянного состояния. Он может дать сбой или 
выключиться, и CS сможет пережить такое событие, перезапустить Адаптер, а затем вернуть его в 
правильное рабочее состояние.

* Если для объекта SAI требуются определенные атрибуты, но они не указаны как часть функции 
создания, то адаптер должен выбрать подходящее значение по умолчанию, если это возможно, или 
отказать, если это невозможно.

* Удаление объекта, на который имеется ссылка, должно завершиться неудачно (например, удаление 
маршрутизатора при наличии интерфейса). 

.. pic::

Рисунок 1: SAI в возможной архитектуре системы коммутации 

**Описание API**

Интерфейс SAI обеспечивает программную абстракцию FE. Его цель состоит в том, чтобы позволить 
разрабатывать клиентскую часть CS интерфейса независимо от FE.

API разработан так, чтобы быть независимым от ОС(nix/Windows/etc)

API основан на атрибутах, чтобы минимизировать проблемы совместимости с управлением версиями 
структур и обеспечить масштабируемость API.

API - это набор интерфейсов в стиле C, предоставляемых Адаптером. Эти интерфейсы сгруппированы в 
три категории: 

* Обязательный функционал. Это набор «основных» API-интерфейсов для основных операций форвардинга,
необходимых для CS. Все реализации Адаптера должны поддерживать эти функции. CS не сможет загрузить
Адаптер, если какая-либо из этих функций отсутствует.

* Дополнительная функциональность. Это набор дополнительных функций, которые определены, но не 
требуются в совместимой реализации Адаптера SAI. Они стандартным образом включают не основные 
функции форвардинга. Они требуются только для реализаций CS, которые их используют. CS не должен 
предполагать, что функции присутствуют в Адаптере (хотя может сделать это).

* Пользовательские функции: это набор дополнительных функций, которые не определены и не требуются 
для реализации совместимого SAI Адаптера. Они используются для специфичных для SAI Адаптера 
расширений, чаще всего для предоставления различной функциональности в FE. Для доступа к этим 
функциям в CS требуется соответствующая поддержка. Более общая структура для раскрытия данной
функциональности через определение кастомных атрибутов будет сделана в будущем проекте.

API обнаруживаются путем запроса таблиц методов с помощью механизма, описанного в разделе
"Functionality query"

SAI - это управляемый (managed) API с поддержкой управления версиями, обеспечивающий определенный 
уровень обратной совместимости. Если сигнатуру или сематику функции необходимо изменить, необходимо 
создать новую функцию (с уникальным ID), оставив предыдущую версию без изменений. Новый ID - это имя
из перечисления, которое кодирует версию (например, SAI_API_VLAN2). AH начинает запрос 
с последней известной ему версией, а затем работает обратно, пока не найдет доступную функцию в 
Адаптере. Если ничего не найдено, функция считается не поддерживаемой, и AH реагирует 
соответствующим образом. 

**Adapter startup/shutdown sequencei**

AH сконфигурирован всем необходимым для загрузки и инициализации Адаптера при запуске.

После загрузки адаптера, AH получает указатели на три хорошо известные функции: 
sai_api_initialize(),  sai_api_query() и sai_api_uninitialize().

Адаптер сначала инициализируется вызовом sai_api_initialize(). Посредством этого Адаптеру передается
таблица методов служб, предоставляемых AH. Инициализация FE в этой функции не выполняется. Её цель -
программная инициализация драйвера. После этого у Адаптера можно запросить таблицы рабочих методов 
SAI".

После инициализации, функицию sai_api_query() можно использовать для поиска различных таблиц методов
для SAI функций.

После успешного запроса всех обязательных функций запрашиваются дополнительные функции. 
Неспособность обнаружить дополнительные функции не обязательно (хотя и может) привести к сбою при 
запуске системы.

После того, как все функции получены, AH переходит к использованию операций Адаптера. 

Например, первый метод, который вызывает AH, - это sai_initialize_switch() для выполнения полной 
инициализации FE. В системе с несколькими AH только один из них должен вызывать указанную выше 
функцию. Другие вызовут sai_connect_switch() для подключения к Aдаптеру после его инициализации. 
Вызов sai_connect_switch() завершится ошибкой, если FE не был инициализирован. Функция 
sai_intialize_switch() принимает следующие параметры:

- дескриптор профиля коммутатора
- аппаратный идентификатор коммутатора (hardware id)
- имя соответствующего микрокода
- таблица callbackов
 
Profile_id используется Адаптером для получения профиля. Это список строковых пар "key-value", 
которые содержат параметры, определенные производителем. Как только у Адаптера есть идентификатор 
профиля, он может использовать функции profile_get_value() и profile_get_next_value() из 
service_method_table_t для получения пар ключ-значение, таких как SDK_LIBRARY_PATH или 
NPU_CONFIG_FILE_PATH. Функция service_method_table_t передается AH во время sai_api_intialize().

Формат и содержимое строки hardware id определяется производителем и содержит достаточно информации
для идентификации устройства и доступа к нему. Например, он может содержать расположение PCIe.

Некоторым Адаптерам может потребоваться загрузить другой объект кода в соответствии с особенностями
системы и FE. Параметр «микрокод» позволяет идентифицировать такой объект. Его формат и значение 
зависят от Aдаптера.

Таблица «обратных вызовов» содержит список колбэков Стека Управления (CS), которые будут 
использоваться для уведомлений.

Обычно функция sai_api_intialize() обнаруживает экземпляр FE, используя строку "HW id", сопоставляет
регистры устройств, запрашивает информацию для определения конкретной ревизии микросхемы и, учитывая
настройки микрокода и профиля, инициализирует FE.

После этого SAI переходит в нормальный режим работы и начинает обрабатывать вызовы от AH к различным
методам различных таблиц функциональных возможностей. Для выключения SAI, AH вызовет 
sai_switch_shutdown(). Эта функция должна вернуть FE в видимое извне состояние, в котором он 
находился до вызова sai_switch_initialize(). То есть внешние видимые ссылки должны быть убраны и 
форвардинг не должен происходить. AH, которые используют sai_connect_switch(), будут использовать 
sai_disconnect_switch() для отключения от адаптера.

sai_api_uninitialize() выполняет очистку всего, что было сделано в sai_api_initialize(), и является
последним вызовом адаптера перед его выгрузкой.

Наконец, AH выгружает модуль Aдаптера. 









